<center>**os14sand15s小组**</center>

<center>程序设计规格说明书</center>
=====
<center><big>实验：OSshell（shell解释器）</big></center>

###一、基本要求的实现
####1.输出提示符，等待用户输入
&#160; &#160; &#160; &#160;通过调用yyparse()，直接使用flex编译flex.l文件生成的一系列函数获得输入，并进行解析。每次获取输入之前，先打印提示符，包括用户名，当前执行路径，主机名。分别由getlogin，get_current_dir_name(),gethostname()这三个函数获得。
####2.实现内部命令
#####（1）exit
&#160; &#160; &#160; &#160;语法分析得到了exit指令，直接执行exit函数，结束该shell程序。
#####（2）jobs
&#160; &#160; &#160; &#160;从头指针遍历作业链表，并打印它们的信息。
#####（3）history
&#160; &#160; &#160; &#160;从输入处保存输入的字符串，调用history将它们打印。
#####（4）bg
&#160; &#160; &#160; &#160;根据pid查找作业，发信号使其运行，修改其状态。
#####（5）fg
&#160; &#160; &#160; &#160;根据pid查找作业，记录前台作业pid，修改状态，发信号使其运行。执行wait函数，shell等待其执行，并在之前执行一下sleep。
####3.实现ctrl+z
&#160; &#160; &#160; &#160;为进程注册信号SIGSTOP，当ctrl+z被使用时，执行函数，发送信号SIGSTOP使其停止，加入作业链表。
####4.实现ctrl+c
&#160; &#160; &#160; &#160;为进程注册信号SIGINT，当ctrl+C被使用时，执行函数，发送信号SIGKILL使其结束。ctrl+c不会终止shell。
####5.实现输入输出重定向
&#160; &#160; &#160; &#160;基本没有对源码做改动。
####6.后台命令 &
&#160; &#160; &#160; &#160;增加sleep（1）避免子父进程互相等待。这种实现方式仍然有随机性，是我们程序的不足之处。
####7.cd命令修正
&#160; &#160; &#160; &#160;不加参数的cd命令将进入/home，与真实的shell一致。
###二、提高要求的实现
####1.flex和bison结合
&#160; &#160; &#160; &#160;flex对内部命令，普通命令，管道命令进行匹配，返回相应的标识符，bison得到后确定指令的类型，执行相应的函数。

&#160; &#160; &#160; &#160;词法分析做的过于粗糙，仍然需要后续对字符串的处理函数将命令解析出来。
####2.实现通配符功能
&#160; &#160; &#160; &#160;通配符“*”和“?”，本质上是对命令的参数的扩充。先由空白符等分割指令，得到字符串中包含的指令参数，检查是否含有通配符。对于含有通配符的字符串，先补全目录名，以方便对路径名的匹配。然后从根目录/开始，每进入一层目录，便用该目录下所有文件名（广义上的文件，包括文件夹）匹配含通配符的字符串。对于每一个匹配成功的，继续进入路径去匹配。这是一个递归的过程，最终匹配的字符串都加入一个链表。命令的参数列表将复制此链表中保存的字符串。
####3.实现对管道的支持
&#160; &#160; &#160; &#160;首先将管道命令解析为一个个普通命令，把它们的输入输出用管道连起来，每一个普通命令都会创建子进程。